/*
参考自：https://mp.weixin.qq.com/s/FYx3acRh9JXAIb7y97G39A
公众号：CodeSheep
羊哥算是我的“启蒙导师”，通过羊哥我才了解到c++，我也一直遵循着羊哥的路线学习c++。
我现在是一名大四学生，履历平平，经历了秋招失利，难受了挺长一段时间。
我意识到我路走歪了，我学习的方法错了。
学编程以来，我一直梦想着去大厂，腾讯、网易、字节等等，不是怀揣着多大的理想，
只是图个工资高福利好而已，但十数次的失利狠狠地打击到了我。华为、腾讯、网易、CVTE等等等等。
我想躺平、想摆烂，说实话，现在家里这条件我也不愁没有房子住，随便找份工作大几千的也不是不能生活。
但是我不想，父母辛苦了大半辈子为我留下了两套房子，我也想为我的子女留下一点什么。
上两个星期，父亲因为肺癌去世，我想了很多，我开始回忆我的大学，浑浑噩噩的度过了大学三年多的时光，
高考的失利磨平了我的信念、坚持，我早已没有当年的激情，我变得冷漠、势利、迷茫。
从小家里人就不用操心我的学习问题，父亲只管照顾我的起居，
我也还算争气，考了所211，好歹给父亲省了不少开销，但我知道，我不属于这里。
事到如今，我也不想让家里人操心我的生计问题，我想拿到一份好的offer，能让我攒钱、
攒不少钱的offer，苦点累点不算什么，母亲为了我熬了大半辈子供我吃穿，
父亲想尽办法为我解决学费、起居问题，临走前还在担心我的健康，比起他们，这些真的不算什么。
我得赚很多钱，有很多人等着我去孝顺他们，妈妈、舅舅、姑妈、姨妈...
我还没出过省，我很想去省外见识高山、云海、江河，我在视频里看过这些优美的景色，
我很想以后亲眼见见。可惜啊，有些人再也看不见了。
脚踏实地，重新出发吧。
祝我春招顺利。
2021.11.25
*/

/*
KMP算法是一种字符串匹配算法，我们把能匹配上的叫好前缀，不能匹配上的叫坏字符。
遇到坏字符后就进行主串的好前缀和后缀子串跟模式串的前缀子串对比。
如暴力破解，遇到坏字符我们只能从模式串开头开始对比，但是KMP算法可以根据主串
的好前缀的后缀子串进行对比，这样就避免了从头匹配。

KMP最重要的是构造next数组，构造完成后就可以根据next数组滑动模式串。
next数组的含义是模式串的[0, i]范围内前缀与后缀相等的最大长度l。
举个例子。
以下有一个字符串
        a   b   a   b   c
index： 0   1   2   3   4
按照算法求得的next数组如下
       -1  -1  0   1   -1  
让我们来捋一下：
next[j]=k的含义就是对于字符串[0,j]的范围内，[0,k]与[j-k,j]是一样的。
那么，当主串第i位与模式串第j+1位不匹配时，模式串就移动到next[j-1]的下一位。

就比如这样：
abacdgh
ababc
第四位匹配不上，那么看一下第三位的值，发现是0，所以应该这样移动
abacdgh
  ababc
然后重新开始匹配
*/

#ifndef _KMP_
#define _KMP_

#include <string>
#include <vector>
using std::string;
using std::vector;

void getNext(vector<int>& next, string& str) {
    next[0] = -1;
    int k = -1;
    size_t strLen = str.size();

    for(size_t i = 1; i < strLen; ++i) {
        // 进行好后缀匹配
        while(k != -1 && str[k+1] != str[i]) {
            k = next[k];
            // 寻找次长串
        }

        if(str[k+1] == str[i]) {
            ++k;    // 前缀长度加1
        }
        next[i] = k;
    }
}

bool kmp(string& source, string& target) {
    int strLen = target.size();
    vector<int> next(strLen, 0);
    getNext(next, target);
    int j = 0;

    for(int i = 0; i < strLen; ++i) {
        while(j > 0 && source[i] != target[j]) {
            j = next[j-1] + 1; // 根据next数组移动模式串
                                // 为什么要加1？因为next[i]记录了好前缀的最后一位
                                // 应该移动到next[i]的下一位重新匹配
        }

        if(source[i] == target[j]) {
            ++j;
        }

        if(strLen == j) {
            return true;
        }
    }
    return false;
}

#endif /* _KMP_ */